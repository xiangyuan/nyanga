--[=[
Copyright (C) 2013-2014 Richard Hundt and contributors.
See Copyright Notice in nyanga
]=]

module AST
   local util = require('nyanga.util')

   static tonumber(s)
      local n = string::gsub(s, '_', '')
      return tonumber(n)
   end
   static tostring(a)
      return tostring(a)
   end

   static octal(s)
      return tostring(tonumber(s, 8))
   end
   static quote(s)
      return string::format("%q", s)
   end
   local escape_lookup = {
      ["a"] = "\a",
      ["b"] = "\b",
      ["f"] = "\f",
      ["n"] = "\n",
      ["r"] = "\r",
      ["t"] = "\t",
      ["v"] = "\v",
      ["0"] = "\0",
      ['"'] = '"',
      ["'"] = "'",
      ["\\"]= "\\"
   }
   static escape(s)
      local t = string::sub(s, 2)
      local n = tonumber(t)
      if n then return string::char(n) end
      if escape_lookup[t] then return escape_lookup[t] end
      error("invalid escape sequence")
   end
   static chunk(body)
      return { type = "Chunk", body = body }
   end
   static stmt(pos, node)
      node.pos = pos
      return node
   end
   static term(pos, node)
      node.pos = pos
      if node.type == 'Identifier' then
         node.check = true
      end
      return node
   end
   static expr(pos, node)
      node.pos = pos
      return node
   end

   static includeStmt(names)
      return { type = "IncludeStatement", names = names }
   end
   static moduleDecl(name, body)
      return { type = "ModuleDeclaration", id = name, body = body }
   end

   static exportStmt(names)
      return { type = "ExportStatement", names = names }
   end
   static rawString(exprs)
      return { type = "RawString", expressions = exprs }
   end
   static rawExpr(expr)
      return { type = "RawExpression", expression = expr }
   end
   static importStmt(names, from, ...)
      return { type = "ImportStatement", names = names, from = from }
   end
   static error(src, pos, name)
      local loc = string::sub(src, pos, pos)
      if loc == '' then
         error("Unexpected end of input", 2)
      else
         local tok = string::match(src, '%s*(%S+)', pos) or loc
         local line = 0
         local ofs  = 0
         while ofs < pos do
            local a, b = string::find(src, "\n", ofs)
            if a then
               ofs = a + 1
               line = line + 1
            else
               break
            end
         end
         error("Unexpected token '"~tok~"' on line "~tostring(line)~" "~tostring(name or '?'), 2)
      end
   end
   static fail(src, pos, msg)
      local loc = string::sub(src, pos, pos)
      if loc == '' then
         error("Unexpected end of input")
      else
         local tok = string::match(src, '(%w+)', pos) or loc
         error(msg~" near '"~tok~"'")
      end
   end
   static literal(val)
      return { type = "Literal", value = val }
   end
   static literalNumber(s)
      return { type = "Literal", value = tonumber(s) }
   end
   static boolean(val)
      return val == 'true'
   end
   static nilExpr()
      return { type = "Literal", value = nil }
   end
   static identifier(name)
      return { type = "Identifier", name = name }
   end
   static compExpr(body, blocks)
      return { type = "ArrayComprehension", blocks = blocks, body = body }
   end
   static compBlock(lhs, rhs, filter)
      return { type = "ComprehensionBlock", left = lhs, right = rhs, filter = filter }
   end
   static arrayExpr(elements)
      return { type = "ArrayExpression", elements = elements }
   end

   static arrayPatt(elements)
      return { type = "ArrayPattern", elements = elements }
   end
   static tablePatt(entries, coerce)
      return { type = "TablePattern", entries = entries, coerce = coerce }
   end
   static applyPatt(expr)
      local base = expr[1]
      for i=2, #expr do
         if expr[i][1] == "(" then
            base = self::callExpr(base, expr[i][2])
         else
            base = self::memberExpr(base, expr[i][2], expr[i][1] == "[")
            base.namespace = expr[i][1] == "::"
         end
      end
      base.type = 'ApplyPattern'
      return base
   end

   static tableEntry(item)
      return item
   end

   static tableExpr(entries)
      return { type = "TableExpression", entries = entries }
   end
   --[[
   static regexExpr(expr, flags)
      local rx = require('pcre')
      expr = string::gsub(expr, "(\\[rnt\\])", self::escape)
      assert(rx.compile(expr))
      return { type = "RegExp", pattern = expr, flags = flags }
   end
   --]]
   static ifStmt(test, cons, altn)
      if cons.type != "BlocKStatement" then
         cons = self::blockStmt{ cons }
      end
      if altn and altn.type != "BlockStatement" then
         altn = self::blockStmt{ altn }
      end
      return { type = "IfStatement", test = test, consequent = cons, alternate = altn }
   end
   static whileStmt(test, body)
      return { type = "WhileStatement", test = test, body = body }
   end
   static repeatStmt(body, test)
      return { type = "RepeatStatement", test = test, body = body }
   end
   static forStmt(name, init, last, step, body)
      return {
         type = "ForStatement",
         name = name, init = init, last = last, step = step,
         body = body
      }
   end
   static forInStmt(left, right, body)
      return { type = "ForInStatement", left = left, right = right, body = body }
   end
   static spreadExpr(arg)
      return { type = "SpreadExpression", argument = arg }
   end
   static funcDecl(path, head, body)
      if body.type != "BlockStatement" then
         body = self::blockStmt{ self::returnStmt{ body } }
      end

      local name, oper
      if path then
         if #path == 1 then
            name = path[1]
         else
            name = util::fold_left(path, function(a, b)
               if type(b) == 'string' then
                  oper = b
                  return a
               else
                  return self::memberExpr(a, b)
               end
            end)
         end
      end

      local decl = { type = "FunctionDeclaration", name = name, body = body }
      local defaults, params, rest = { }, { }, nil
      if oper == '.' then
         params[#params + 1] = self::identifier('self')
      end
      for i=1, #head do
         local p = head[i]
         if p.rest then
            rest = p.name
         else
            params[#params + 1] = p.name
            if p.default then
               defaults[i] = p.default
            end
         end 
      end

      decl.params   = params
      decl.defaults = defaults
      decl.rest     = rest

      return decl
   end
   static funcExpr(head, body)
      local decl = self::funcDecl(nil, head, body)
      decl.expression = true
      return decl
   end
   static coroExpr(...)
      local expr = self::funcExpr(...)
      expr.generator = true
      return expr
   end
   static coroDecl(...)
      local decl = self::funcDecl(...)
      decl.generator = true
      return decl
   end
   static coroProp(...)
      local prop = self::propDefn(...)
      prop.generator = true
      return prop
   end
   static blockStmt(body)
      return {
         type = "BlockStatement",
         body = body
      }
   end
   static givenStmt(disc, cases, default)
      if default then
         cases[#cases + 1] = self::givenCase(nil, default)
      end
      return { type = "GivenStatement", discriminant = disc, cases = cases }
   end
   static givenCase(test, cons)
      return { type = "GivenCase", test = test, consequent = cons }
   end

   static returnStmt(args)
      return { type = "ReturnStatement", arguments = args }
   end
   static yieldStmt(args)
      return { type = "YieldStatement", arguments = args }
   end
   static breakStmt()
      return { type = "BreakStatement" }
   end
   static continueStmt()
      return { type = "ContinueStatement" }
   end
   static throwStmt(expr)
      return { type = "ThrowStatement", argument = expr }
   end
   static tryStmt(body, handlers, finalizer)
      local guarded = { }
      local handler
      for i=1, #handlers do
         if handlers[i].guard then
            guarded[#guarded + 1] = handlers[i]
         else
            assert(i == #handlers, "catch all handler must be last")
            handler = handlers[i]
         end
      end
      return {
         type = "TryStatement",
         body = body,
         handler = handler,
         guardedHandlers = guarded,
         finalizer = finalizer
      }
   end
   static catchClause(param, guard, body)
      if not body then body, guard = guard, nil end
      return { type = "CatchClause", param = param, guard = guard, body = body }
   end

   static classDecl(name, base, body)
      if #base == 0 and not base.type then
         base = nil
      end
      return { type = "ClassDeclaration", id = name, base = base, body = body }
   end
   static classBody(body)
      return { type = "ClassBody", body = body }
   end
   static classMember(s, m)
      m['static'] = s == "static"
      if not m['static'] then
         table::insert(m.value.params, 1, self::identifier("self"))
      end
      return m
   end
   static propDefn(k, n, h, b)
      local func = self::funcExpr(h, b)
      for i=#func.defaults, 1, -1 do
         func.defaults[i + 1] = func.defaults[i]
      end
      func.defaults[1] = nil
      return { type = "PropertyDefinition", kind = k, key = n, value = func }
   end
   static exprStmt(pos, expr)
      return { type = "ExpressionStatement", expression = expr, pos = pos }
   end
   static selfExpr()
      return { type = "SelfExpression" }
   end
   static superExpr()
      return { type = "SuperExpression" }
   end
   static prefixExpr(o, a)
      return { type = "UnaryExpression", operator = o, argument = a }
   end
   static postfixExpr(expr)
      local base = expr[1]
      for i=2, #expr do
         if expr[i][1] == "(" then
            base = self::callExpr(base, expr[i][2])
         else
            base = self::memberExpr(base, expr[i][2], expr[i][1] == "[")
            base.namespace = expr[i][1] == "::"
         end
      end
      return base
   end
   static memberExpr(b, e, c)
      return { type = "MemberExpression", object = b, property = e, computed = c }
   end
   static callExpr(expr, args)
      return { type = "CallExpression", callee = expr, arguments = args } 
   end
   static newExpr(expr, args)
      return { type = "NewExpression", callee = expr, arguments = args } 
   end

   static binaryExpr(op, lhs, rhs)
      return { type = "BinaryExpression", operator = op, left = lhs, right = rhs }
   end
   static logicalExpr(op, lhs, rhs)
      return { type = "LogicalExpression", operator = op, left = lhs, right = rhs }
   end
   static assignExpr(lhs, rhs)
      return { type = "AssignmentExpression", left = lhs, right = rhs }
   end
   static updateExpr(left, op, right)
      return { type = "UpdateExpression", left = left, operator = op, right = right }
   end
   static localDecl(lhs, rhs)
      return { type = "VariableDeclaration", names = lhs, inits = rhs }
   end
   static doStmt(block)
      return { type = "DoStatement", body = block }
   end

   local op_info = {
      ["or"]  = { 1, 'L' },
      ["and"] = { 2, 'L' },

      ["|"]   = { 4, 'L' },
      ["^"]   = { 5, 'L' },
      ["&"]   = { 6, 'L' },

      ["=="]  = { 7, 'L' },
      ["!="]  = { 7, 'L' },

      ["is"]  = { 8, 'L' },
      ["as"]  = { 8, 'L' },
      ["in"]  = { 9, 'L' },

      [">="]  = { 10, 'L' },
      ["<="]  = { 10, 'L' },
      [">"]   = { 10, 'L' },
      ["<"]   = { 10, 'L' },

      ["<<"]  = { 11, 'L' },
      [">>"]  = { 11, 'L' },
      [">>>"] = { 11, 'L' },

      ["+"]   = { 12, 'L' },
      ["-"]   = { 12, 'L' },
      [".."]  = { 12, 'R' },

      ["*"]   = { 13, 'L' },
      ["/"]   = { 13, 'L' },
      ["%"]   = { 13, 'L' },

      ["~_"]  = { 14, 'R' },
      ["-_"]  = { 14, 'R' },
      ["+_"]  = { 14, 'R' },
      ["!_"]  = { 14, 'R' },

      ["not_"]    = { 14, 'R' },
      ["typeof_"] = { 14, 'R' },

      ["**"]  = { 15, 'R' },
      ["#_"]  = { 16, 'R' },
   }

   local patt_op_info = {
      ["~>"]  = { 1, 'L' },
      ["->"]  = { 1, 'L' },
      ["+>"]  = { 1, 'L' },

      ["|"]   = { 2, 'L' },

      ["&_"]  = { 3, 'R' },
      ["!_"]  = { 3, 'R' },

      ["+"]   = { 3, 'L' },
      ["*"]   = { 3, 'L' },
      ["?"]   = { 3, 'L' },

      ["^+"]  = { 4, 'R' },
      ["^-"]  = { 4, 'R' },
   }

   local shift = table::remove

   function debug(t)
      return (string::gsub(util::dump(t), "%s+", " "))
   end

   function fold_expr(exp, min)
      local lhs = shift(exp, 1)
      if type(lhs) == 'table' and lhs.type == 'UnaryExpression' then
         local op   = lhs.operator~'_'
         local info = op_info[op]
         table::insert(exp, 1, lhs.argument)
         lhs.argument = fold_expr(exp, info[1])
      end
      while op_info[exp[1]] != nil and op_info[exp[1]][1] >= min do
         local op = shift(exp, 1)
         local info = op_info[op]
         local prec, assoc = info[1], info[2]
         if assoc == 'L' then
            prec = prec + 1
         end
         local rhs = fold_expr(exp, prec)
         if op == "or" or op == "and" then
            lhs = self::logicalExpr(op, lhs, rhs)
         else
            lhs = self::binaryExpr(op, lhs, rhs)
         end
      end
      return lhs
   end

   static infixExpr(exp)
      return fold_expr(exp, 0)
   end

   static regexExpr(expr)
      return { type = "RegExp", pattern = expr }
   end

   static grammarDecl(name, body)
      return { type = "GrammarDeclaration", id = name, body = body }
   end
   static pattGrammar(rules)
      return { type = "PatternGrammar", rules = rules }
   end

   static pattExpr(pass)
      return pass -- for now
   end

   static pattAlt(list)
      return util::fold_left(list, function(a, b)
         return { type = "PatternAlternate", left = a, right = b }
      end)
   end
   static pattSeq(list)
      return util::fold_left(list, function(a, b)
         return { type = "PatternSequence", left = a, right = b }
      end)
   end
   static pattAny()
      return { type = "PatternAny" }
   end
   static pattAssert(oper, term)
      return { type = "PatternAssert", operator = oper, argument = term }
   end

   static pattSuffix(term, tail)
      if #tail == 0 then
         return term
      end
      local left = term
      for i=1, #tail do
         tail[i].left = left
         left = tail[i]
      end
      return left
   end
   static pattProd(oper, expr)
      return { type = "PatternProduction", operator = oper, right = expr }
   end
   static pattOpt(oper)
      local count
      if oper == '?' then
         count = -1
      elseif oper == '*' then
         count = 0
      else assert(oper == '+')
         count = 1
      end
      return { type = "PatternRepeat", count = count }
   end
   static pattRep(count)
      return { type = "PatternRepeat", count = tonumber(count) }
   end

   static pattCaptSubst(expr)
      return { type = "PatternCaptSubst", pattern = expr }
   end
   static pattCaptTable(expr)
      return { type = "PatternCaptTable", pattern = expr or self::literal("") }
   end
   static pattCaptBasic(expr)
      return { type = "PatternCaptBasic", pattern = expr }
   end
   static pattCaptConst(expr)
      return { type = "PatternCaptConst", argument = expr }
   end
   static pattCaptGroup(name, expr)
      return { type = "PatternCaptGroup", name = name, pattern = expr }
   end
   static pattCaptBack(name)
      return { type = "PatternCaptBack", name = name }
   end
   static pattRef(name)
      return { type = "PatternReference", name = name }
   end
   static pattClass(prefix, items)
      local expr = util::fold_left(items, function(a, b)
         return { type = "PatternAlternate", left = a, right = b }
      end)
      return { type = "PatternClass", negated = prefix == '^', alternates = expr }
   end
   static pattRange(left, right)
      return { type = "PatternRange", left = left, right = right }
   end
   static pattName(name)
      return name
   end
   static pattTerm(literal)
      return { type = "PatternTerm", literal = literal }
   end
   static pattPredef(name)
      return { type = "PatternPredef", name = name }
   end
   static pattArg(index)
      return { type = "PatternArgument", index = index }
   end
end

export AST

