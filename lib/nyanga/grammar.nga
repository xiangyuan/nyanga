--[=[
Copyright (C) 2013-2014 Richard Hundt and contributors.
See Copyright Notice in nyanga
]=]

import AST from 'nyanga/parser/ast.nga'

grammar Nyanga
   chunk  <- {|
      s (<main_stmt> (<sep> s <main_stmt>)* <sep>?)? s (!. | %1 +> error)
   |} -> AST.chunk

   close    <- ']' =eq ']' | . <close>

   lcomment <- "--" (!%nl .)* %nl
   bcomment <- ('--[' {:eq: '='* :} '[' <close>)
   comment  <- <bcomment> | <lcomment>
   idsafe   <- !(%alnum | "_")
   s        <- (<comment> | %s)*
   S        <- (<comment> | %s)+
   hs       <- (!%nl %s)*
   HS       <- (!%nl %s)+
   digits   <- %digit (%digit | (&('_' %digit) '_') %digit)*
   word     <- (%alpha | "_") (%alnum | "_")*

   keyword  <- (
      "local" | "function" | "class" | "module" | "static"
      | "nil" | "true" | "false" | "return" | "end"
      | "yield" | "break" | "continue" | "not" | "throw"
      | "while" | "do" | "for" | "in" | "of" | "and" | "or"
      | "super" | "import" | "export" | "try" | "catch" | "finally"
      | "if" | "elseif" | "else" | "then" | "is" | "as" | "include"
      | "repeat" | "until" | "grammar" | "rule" | "given" | "case"
   ) <idsafe>

   sep <- <bcomment>? (%nl | ";" | <lcomment>) | %s <sep>?

   escape <- {~ ('\' (%digit^3 | .)) -> AST.escape ~} --'

   astring <- "'" {~ (<escape> | {!"'" .})* ~} "'"

   qstring <- {|
      '"' (
         <raw_expr> | {~ (<escape> | !(<raw_expr> | '"') .)+ ~}
      )* '"'
   |} -> AST.rawString

   raw_expr <- (
      "${" s <expr> s "}"
   ) -> AST.rawExpr

   string  <- <astring>

   hexnum <- "-"? "0x" %xdigit+

   decexp <- ("e"|"E") "-"? <digits>

   decimal <- "-"? <digits> ("." <digits> <decexp>? | <decexp>)

   integer <- "-"? <digits>

   octal   <- {~ { "-"? "0" [0-7]+ } -> AST.octal ~}

   number  <- {~
      <hexnum> | <octal> | <decimal> | <integer>
   ~} -> AST.tonumber

   boolean <- (
      {"true"|"false"} <idsafe>
   ) -> AST.boolean

   literal <- ( <number> | <string> | <boolean> ) -> AST.literal

   main_stmt <- (
      <export_stmt> | <stmt>
   )

   in  <- "in"  <idsafe>
   end <- "end" <idsafe>
   do  <- "do"  <idsafe>

   export_stmt <- (
      "export" <idsafe> s {| <name_list> |}
   ) -> AST.exportStmt

   import_stmt <- (
      "import" <idsafe> s {| <ident> (s "," s <ident>)* |} s
      "from" <idsafe> s <expr>
   ) -> AST.importStmt

   stmt <- (%pos (
      <import_stmt>
      | <if_stmt>
      | <while_stmt>
      | <repeat_stmt>
      | <for_stmt>
      | <for_in_stmt>
      | <do_stmt>
      | <expr_stmt>
      | <decl_stmt>
      | <return_stmt>
      | <try_stmt>
      | <throw_stmt>
      | <break_stmt>
      | <continue_stmt>
      | <yield_stmt>
      | <given_stmt>
   )) -> AST.stmt

   stmt_list <- {|
      (<stmt> (<sep> s <stmt>)* <sep>?)?
   |}

   break_stmt <- (
      "break" <idsafe>
   ) -> AST.breakStmt

   continue_stmt <- (
      "continue" <idsafe>
   ) -> AST.continueStmt

   yield_stmt <- (
      "yield" <idsafe> {| (HS  <expr_list>)? |}
   ) -> AST.yieldStmt

   return_stmt <- (
      "return" <idsafe> {| (HS <expr_list>)? |}
   ) -> AST.returnStmt

   throw_stmt <- (
      "throw" <idsafe> s <expr>
   ) -> AST.throwStmt

   try_stmt <- (
      "try" <idsafe> s <block_stmt>
      {| <catch_clause>* |} (s "finally" <idsafe> s <block_stmt>)?
      s <end>
   ) -> AST.tryStmt

   catch_clause <- (
      s "catch" <idsafe> s "(" s
      <ident> (s "if" <idsafe> s <expr>)? s ")" s <block_stmt> s
   ) -> AST.catchClause

   decl_stmt <- (
        <local_decl>
      | <coro_decl>
      | <func_decl>
      | <class_decl>
      | <module_decl>
      | <grammar_decl>
   )

   local_decl <- (
      "local" <idsafe> s {|
         <decl_left> (s "," s <decl_left>)*
      |} (s "=" s {| <expr_list> |})?
   ) -> AST.localDecl

   bind_left <- (
      <array_patt> | <table_patt> | <apply_patt> | <member_expr>
   )
   decl_left <- (
      <array_patt_decl> | <table_patt_decl> | <apply_patt_decl> | <ident>
   )

   array_patt <- (
      "[" s {| <bind_left> (s "," s <bind_left>)* |} s "]"
   ) -> AST.arrayPatt

   array_patt_decl <- (
      "[" s {| <decl_left> (s "," s <decl_left>)* |} s "]"
   ) -> AST.arrayPatt

   table_sep <- (
      hs (","|";"|%nl)
   )
   table_patt <- (
      "{" s {|
         <table_patt_pair> (<table_sep> s <table_patt_pair>)*
         <table_sep>?
      |} s "}"
      (hs "as" <idsafe> hs <expr>)?
   ) -> AST.tablePatt

   table_patt_decl <- (
      "{" s {|
         <table_patt_pair_decl> (<table_sep> s <table_patt_pair_decl>)*
         <table_sep>?
      |} s "}"
      (hs "as" <idsafe> hs <expr>)?
   ) -> AST.tablePatt

   table_patt_pair <- {|
      ( {:name: <word> -> AST.identifier :} | {:expr: "[" s <expr> s "]" :} ) s
      "=" s {:value: <bind_left> :}
      | {:value: <bind_left> :}
   |}

   table_patt_pair_decl <- {|
      ( {:name: <word> -> AST.identifier :} | {:expr: "[" s <expr> s "]" :} ) s
      "=" s {:value: <decl_left> :}
      | {:value: <decl_left> :}
   |}

   apply_patt <- {|
      <term> <apply_tail>* <apply_call>
   |} -> AST.applyPatt

   apply_patt_decl <- {|
      <term> <apply_tail>* <apply_call_decl>
   |} -> AST.applyPatt

   apply_tail <- {|
        s { "." } s <ident>
      | s { "::" } s (<ident> | %1 +> error)
      | s { "[" } s <expr> s ("]" | %1 +> error)
   |}

   apply_call <- {|
      { "(" } s {| <bind_left> (s "," s <bind_left>)* |} s ")"
   |}
   apply_call_decl <- {|
      { "(" } s {| <decl_left> (s "," s <decl_left>)* |} s ")"
   |}

   name_list <- (
      <ident> (s "," s <ident>)*
   )

   expr_list <- (
      <expr> (s "," s <expr>)*
   )

   func_path <- (
      (<ident> (s {"."} s <func_path> | s {"::"} s <ident>)) | <ident>
   )

   func_decl <- (
      "function" <idsafe> s {| <func_path> |} s <func_head> s <func_body>
   ) -> AST.funcDecl

   func_head <- (
      "(" s {| <param_list>? |} s ")"
   )

   func_expr <- (
      "function" <idsafe> s <func_head> s <func_body>
      | (<func_head> | {| |}) s "=>" s (<block_stmt> s <end> | <expr> | %1 +> error)
   ) -> AST.funcExpr

   func_body <- <block_stmt> s (<end> | %1 +> error)

   coro_expr <- (
      "function*" s <func_head> s <func_body>
      | "*" <func_head> s "=>" s (<block_stmt> s <end> | <expr> | %1 +> error)
   ) -> AST.coroExpr

   coro_decl <- (
      "function*" s {| <func_path> |} s <func_head> s <func_body>
   ) -> AST.coroDecl

   coro_prop <- (
      ({"get"|"set"} <idsafe> s | '' -> AST."init") "*" <ident> s
      <func_head> s <func_body>
   ) -> AST.coroProp

   include_stmt <- (
      "include" <idsafe> s {| <name_list> |}
   ) -> AST.includeStmt

   module_decl <- (
      "module" <idsafe> s <ident> s
      <class_body> s
      (<end> | %1 +> error)
   ) -> AST.moduleDecl

   class_decl <- (
      "class" <idsafe> s <ident> (s <class_heritage>)? s
      <class_body> s
      (<end> | %1 +> error)
   ) -> AST.classDecl

   class_body <- {|
      (<class_body_stmt> (<sep> s <class_body_stmt>)* <sep>?)?
   |} -> AST.classBody

   class_body_stmt <- (%pos (
      <class_member> | <include_stmt> | !<return_stmt> <stmt>
   )) -> AST.stmt

   class_member <- (
      ({"static"} <idsafe> s | '' -> AST."virt") (<coro_prop> | <prop_defn>)
   ) -> AST.classMember

   class_heritage <- (
      "extends" <idsafe> s <expr> | {| |}
   )

   prop_defn <- (
      ({"get"|"set"} <idsafe> s | '' -> AST."init") <ident> s
      <func_head> s <func_body>
   ) -> AST.propDefn

   param <- {|
      {:name: <ident> :} (s "=" s {:default: <expr> :})?
   |}
   param_list <- (
        <param> s "," s <param_list>
      | <param> s "," s <param_rest>
      | <param>
      | <param_rest>
   )

   param_rest <- {| "..." {:name: <ident>? :} {:rest: '' -> AST.'true' :} |}

   block_stmt <- (
      {| (<stmt> (<sep> s <stmt>)* <sep>?)? |}
   ) -> AST.blockStmt

   if_stmt <- (
      "if" <idsafe> s <expr> s "then" <idsafe> s <block_stmt> s (
           "else" <if_stmt>
         | "else" <idsafe> s <block_stmt> s (<end> | %1 +> error)
         | (<end> | %1 +> error)
      )
   ) -> AST.ifStmt

   given_stmt <- (
      "given" <idsafe> s <expr>
         {| <given_case>+ |}
         (s "else" <idsafe> s <block_stmt>)? s
      (<end> | %1 +> error)
   ) -> AST.givenStmt

   given_case <- (
      s "case" <idsafe> s <bind_left> s "then" <idsafe> s <block_stmt>
   ) -> AST.givenCase

   for_stmt <- (
      "for" <idsafe> s <ident> s "=" s <expr> s "," s <expr>
      (s "," s <expr> | ('' -> AST.'1') -> AST.literalNumber) s
      <loop_body>
   ) -> AST.forStmt

   for_in_stmt <- (
      "for" <idsafe> s {| <name_list> |} s <in> s <expr> s
      <loop_body>
   ) -> AST.forInStmt

   loop_body <- <do> s <block_stmt> s <end>

   do_stmt <- <loop_body> -> AST.doStmt

   while_stmt <- (
      "while" <idsafe> s <expr> s <loop_body>
   ) -> AST.whileStmt

   repeat_stmt <- (
      "repeat" <idsafe> s <block_stmt> s "until" <idsafe> s <expr>
   ) -> AST.repeatStmt

   ident <- (
      !<keyword> { <word> }
   ) -> AST.identifier

   term <- (%pos (
        <coro_expr>
      | <func_expr>
      | <nil_expr>
      | <super_expr>
      | <comp_expr>
      | <table_expr>
      | <array_expr>
      | <regex_expr>
      | <ident>
      | <literal>
      | <qstring>
      | "(" s <expr> s ")"
   )) -> AST.term

   expr <- (%pos (<infix_expr> | <spread_expr>)) -> AST.expr

   spread_expr <- (
      "..." <postfix_expr>?
   ) -> AST.spreadExpr

   nil_expr <- (
      "nil" <idsafe>
   ) -> AST.nilExpr

   super_expr <- (
      "super" <idsafe>
   ) -> AST.superExpr

   expr_stmt <- (
      %pos (<assign_expr> | <update_expr> | <postfix_expr>)
   ) -> AST.exprStmt

   binop <- {
      "+" | "-" | "~" | "/" | "**" | "*" | "%" | "^" | "|" | "&"
      | ">>>" | ">>" | ">=" | ">" | "<<" | "<=" | "<" | ".."
      | "!=" | "==" | ("or" | "and" | "is" | "as") <idsafe>
   }

   infix_expr  <- (
      {| <prefix_expr> (s <binop> s <prefix_expr>)+ |}
   ) -> AST.infixExpr | <prefix_expr>

   prefix_expr <- (
      { "#" | "~" | "+" | "-" | "!" | ("not" | "typeof") <idsafe> } s <prefix_expr>
   ) -> AST.prefixExpr | <postfix_expr>

   postfix_expr <- {|
      <term> <postfix_tail>+
   |} -> AST.postfixExpr | <term>

   postfix_tail <- {|
        s { "." } s <ident>
      | s { "::" } s (<ident> | %1 +> error)
      | hs { "[" } s <expr> s ("]" | %1 +> error)
      | { "(" } s {| <expr_list>? |} s (")" | %1 +> error)
      | {~ (hs &['"[{] | HS) -> AST."(" ~} {| !<binop> <expr_list> |} --'
   |}

   member_expr <- {|
      <term> <member_next>?
   |} -> AST.postfixExpr | <term>

   member_next <- (
      <postfix_tail> <member_next> | <member_tail>
   )
   member_tail <- {|
        s { "." } s <ident>
      | s { "::" } s <ident>
      | s { "[" } s <expr> s ("]" | %1 +> error)
   |}

   assop <- {
      "+=" | "-=" | "~=" | "**=" | "*=" | "/=" | "%=" | "and="
      | "|=" | "or=" | "&=" | "^=" | "<<=" | ">>>=" | ">>="
   }

   assign_expr <- (
      {| <bind_left> (s "," s <bind_left>)* |} s "=" s {| <expr_list> |}
   ) -> AST.assignExpr

   update_expr <- (
      <bind_left> s <assop> s <expr>
   ) -> AST.updateExpr

   array_expr <- (
      "[" s {| <array_elements>? |} s "]"
   ) -> AST.arrayExpr

   array_elements <- <expr> (s "," s <expr>)* (s ",")?

   table_expr <- (
      "{" s {| <table_entries>? |} s "}"
   ) -> AST.tableExpr

   table_entries <- (
      <table_entry> (<table_sep> s <table_entry>)* <table_sep>?
   )
   table_entry <- {|
      ( {:name: <word> -> AST.identifier :} | {:expr: "[" s <expr> s "]" :} ) s
      "=" s {:value: <expr> :}
      | {:value: <expr> :}
   |} -> AST.tableEntry

   comp_expr <- (
      "[" s <expr> {| (s <comp_block>)+ |} s "]"
   ) -> AST.compExpr

   comp_block <- (
      "for" <idsafe> s {| <name_list> |} s <in> s <expr>
      (s "if" <idsafe> s <expr>)? s
   ) -> AST.compBlock

   regex_expr <- (
      "|" s <patt_expr> s ("|" | %s +> error)
   ) -> AST.regexExpr

   grammar_decl <- (
      "grammar" <idsafe> HS <ident> (s <grammar_body>)? s
      (<end> | %1 +> error)
   ) -> AST.grammarDecl

   grammar_body <- <patt_expr>

   patt_expr <- (<patt_grammar> | <patt_alt>) -> AST.pattExpr

   patt_grammar <- {|
      <patt_decl> (s <patt_decl>)*
   |} -> AST.pattGrammar

   patt_decl <- (
      <patt_name> s '<-' s <patt_expr>
   )

   patt_sep <- '|' !'}'
   patt_alt <- {|
      <patt_seq> (s <patt_sep> s <patt_seq>)*
   |} -> AST.pattAlt

   patt_seq <- {|
      (<patt_prefix> (s <patt_prefix>)*)?
   |} -> AST.pattSeq

   patt_any <- '.' -> AST.pattAny

   patt_prefix <- (
      <patt_assert> | <patt_suffix>
   )

   patt_assert  <- (
      {'&' | '!' } s <patt_prefix>
   ) -> AST.pattAssert

   patt_suffix <- (
      <patt_primary> {| (s <patt_tail>)* |}
   ) -> AST.pattSuffix

   patt_tail <- (
      <patt_opt> | <patt_rep> | <patt_prod>
   )

   patt_prod <- (
        {'~>'} s <prefix_expr>
      | {'->'} s <prefix_expr>
      | {'+>'} s <prefix_expr>
   ) -> AST.pattProd

   patt_opt <- (
      !'+>' { [+*?] }
   ) -> AST.pattOpt

   patt_rep <- (
      '^' { [+-]? <patt_num> }
   ) -> AST.pattRep

   patt_capt <- (
        <patt_capt_subst>
      | <patt_capt_const>
      | <patt_capt_group>
      | <patt_capt_table>
      | <patt_capt_basic>
      | <patt_capt_back>
   )

   patt_capt_subst <- (
      '{~' s <patt_expr> s '~}'
   ) -> AST.pattCaptSubst

   patt_capt_group <- (
      '{:' (<patt_name> ':')? s <patt_expr> s ':}'
   ) -> AST.pattCaptGroup

   patt_capt_table <- (
      '{|' s <patt_expr> s '|}'
   ) -> AST.pattCaptTable

   patt_capt_basic <- (
      '{' s <patt_expr> s '}'
   ) -> AST.pattCaptBasic

   patt_capt_const <- (
      '{`'  s <expr> s '`}'
   ) -> AST.pattCaptConst

   patt_capt_back <- (
      '=' <patt_name>
   ) -> AST.pattCaptBack

   patt_primary  <- (
      '(' s <patt_expr> s ')'
      | <patt_term>
      | <patt_class>
      | <patt_predef>
      | <patt_capt>
      | <patt_arg>
      | <patt_any>
      | <patt_ref>
      | '<{' s <expr> s '}>'
   )

   patt_ref <- (
      '<' <patt_name> '>'
      | !<keyword> <patt_name> !(s '<-')
   ) -> AST.pattRef

   patt_arg <- (
      '%' { <patt_num> }
   ) -> AST.pattArg

   patt_class <- (
      '[' {'^' | ''} {| <patt_item> (!']' <patt_item>)* |} ']'
   ) -> AST.pattClass

   patt_item <- (
      <patt_predef> | <patt_range> | ({ . } -> AST.pattTerm)
   )

   patt_range   <- ({ . } '-' { [^]] }) -> AST.pattRange
   patt_name    <- { [A-Za-z_][A-Za-z0-9_]* } -> AST.pattName
   patt_num     <- [0-9]+
   patt_term    <- ('"' { [^"]* } '"' | "'" { [^']* } "'") -> AST.pattTerm --'
   patt_predef  <- '%' <patt_name> -> AST.pattPredef

end

function parse(src, ...)
   return Nyanga.match(src, nil, ...)
end

export parse

